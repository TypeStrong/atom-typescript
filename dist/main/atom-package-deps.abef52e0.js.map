{"mappings":"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","sources":["./node_modules/atom-package-deps/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar os = require('os');\nvar child_process = require('child_process');\nvar fs = require('fs');\nvar path = require('path');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar os__default = /*#__PURE__*/_interopDefaultLegacy(os);\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\nvar path__default = /*#__PURE__*/_interopDefaultLegacy(path);\n\nvar indentString = (string, count = 1, options) => {\n\toptions = {\n\t\tindent: ' ',\n\t\tincludeEmptyLines: false,\n\t\t...options\n\t};\n\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``\n\t\t);\n\t}\n\n\tif (typeof count !== 'number') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``\n\t\t);\n\t}\n\n\tif (typeof options.indent !== 'string') {\n\t\tthrow new TypeError(\n\t\t\t`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``\n\t\t);\n\t}\n\n\tif (count === 0) {\n\t\treturn string;\n\t}\n\n\tconst regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n\n\treturn string.replace(regex, options.indent.repeat(count));\n};\n\nconst extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/;\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\nconst homeDir = typeof os__default['default'].homedir === 'undefined' ? '' : os__default['default'].homedir();\n\nvar cleanStack = (stack, options) => {\n\toptions = Object.assign({pretty: false}, options);\n\n\treturn stack.replace(/\\\\/g, '/')\n\t\t.split('\\n')\n\t\t.filter(line => {\n\t\t\tconst pathMatches = line.match(extractPathRegex);\n\t\t\tif (pathMatches === null || !pathMatches[1]) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tconst match = pathMatches[1];\n\n\t\t\t// Electron\n\t\t\tif (\n\t\t\t\tmatch.includes('.app/Contents/Resources/electron.asar') ||\n\t\t\t\tmatch.includes('.app/Contents/Resources/default_app.asar')\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn !pathRegex.test(match);\n\t\t})\n\t\t.filter(line => line.trim() !== '')\n\t\t.map(line => {\n\t\t\tif (options.pretty) {\n\t\t\t\treturn line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, '~')));\n\t\t\t}\n\n\t\t\treturn line;\n\t\t})\n\t\t.join('\\n');\n};\n\nconst cleanInternalStack = stack => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\nclass AggregateError extends Error {\n\tconstructor(errors) {\n\t\tif (!Array.isArray(errors)) {\n\t\t\tthrow new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n\t\t}\n\n\t\terrors = [...errors].map(error => {\n\t\t\tif (error instanceof Error) {\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\tif (error !== null && typeof error === 'object') {\n\t\t\t\t// Handle plain error objects with message property and/or possibly other metadata\n\t\t\t\treturn Object.assign(new Error(error.message), error);\n\t\t\t}\n\n\t\t\treturn new Error(error);\n\t\t});\n\n\t\tlet message = errors\n\t\t\t.map(error => {\n\t\t\t\t// The `stack` property is not standardized, so we can't assume it exists\n\t\t\t\treturn typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n\t\t\t})\n\t\t\t.join('\\n');\n\t\tmessage = '\\n' + indentString(message, 4);\n\t\tsuper(message);\n\n\t\tthis.name = 'AggregateError';\n\n\t\tObject.defineProperty(this, '_errors', {value: errors});\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const error of this._errors) {\n\t\t\tyield error;\n\t\t}\n\t}\n}\n\nvar aggregateError = AggregateError;\n\nvar pMap = async (\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Infinity,\n\t\tstopOnError = true\n\t} = {}\n) => {\n\treturn new Promise((resolve, reject) => {\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst iterator = iterable[Symbol.iterator]();\n\t\tlet isRejected = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\n\t\tconst next = () => {\n\t\t\tif (isRejected) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = iterator.next();\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0) {\n\t\t\t\t\tif (!stopOnError && errors.length !== 0) {\n\t\t\t\t\t\treject(new aggregateError(errors));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\t\t\t\t\tresult[index] = await mapper(element, index);\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\tisRejected = true;\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\tfor (let i = 0; i < concurrency; i++) {\n\t\t\tnext();\n\n\t\t\tif (isIterableDone) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t});\n};\n\nconst pMap$1 = (iterable, mapper, options) => new Promise((resolve, reject) => {\n\toptions = Object.assign({\n\t\tconcurrency: Infinity\n\t}, options);\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tconst {concurrency} = options;\n\n\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tconst ret = [];\n\tconst iterator = iterable[Symbol.iterator]();\n\tlet isRejected = false;\n\tlet isIterableDone = false;\n\tlet resolvingCount = 0;\n\tlet currentIndex = 0;\n\n\tconst next = () => {\n\t\tif (isRejected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextItem = iterator.next();\n\t\tconst i = currentIndex;\n\t\tcurrentIndex++;\n\n\t\tif (nextItem.done) {\n\t\t\tisIterableDone = true;\n\n\t\t\tif (resolvingCount === 0) {\n\t\t\t\tresolve(ret);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresolvingCount++;\n\n\t\tPromise.resolve(nextItem.value)\n\t\t\t.then(element => mapper(element, i))\n\t\t\t.then(\n\t\t\t\tvalue => {\n\t\t\t\t\tret[i] = value;\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terror => {\n\t\t\t\t\tisRejected = true;\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t);\n\t};\n\n\tfor (let i = 0; i < concurrency; i++) {\n\t\tnext();\n\n\t\tif (isIterableDone) {\n\t\t\tbreak;\n\t\t}\n\t}\n});\n\nvar pMap_1 = pMap$1;\n// TODO: Remove this for the next major release\nvar _default = pMap$1;\npMap_1.default = _default;\n\nconst pFilter = async (iterable, filterer, options) => {\n\tconst values = await pMap_1(\n\t\titerable,\n\t\t(element, index) => Promise.all([filterer(element, index), element]),\n\t\toptions\n\t);\n\treturn values.filter(value => Boolean(value[0])).map(value => value[1]);\n};\n\nvar pFilter_1 = pFilter;\n// TODO: Remove this for the next major release\nvar _default$1 = pFilter;\npFilter_1.default = _default$1;\n\nconst IS_ATOM = typeof atom !== 'undefined';\nconst IS_DEV = typeof atom !== 'undefined' && (atom.inDevMode() || atom.inSpecMode());\nconst IGNORED_CONFIG_NAME = 'atom-package-deps.ignored';\n\n/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nvar escapeHtml_1 = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n\nasync function spawnInternal(command, args, options) {\n    const spawnedProcess = child_process.spawn(command, args, options);\n    const promise = new Promise((resolve, reject) => {\n        const output = {\n            stdout: spawnedProcess.stdout ? [] : null,\n            stderr: spawnedProcess.stderr ? [] : null,\n        };\n        spawnedProcess.on('error', reject);\n        if (spawnedProcess.stdout) {\n            spawnedProcess.stdout.on('data', function (chunk) {\n                output.stdout.push(chunk);\n                if (options.handleStdout) {\n                    options.handleStdout(chunk);\n                }\n            });\n        }\n        if (spawnedProcess.stderr) {\n            spawnedProcess.stderr.on('data', function (chunk) {\n                output.stderr.push(chunk);\n                if (options.handleStderr) {\n                    options.handleStderr(chunk);\n                }\n            });\n        }\n        spawnedProcess.on('close', code => {\n            let outputStdout = null;\n            if (output.stdout != null) {\n                outputStdout =\n                    options.encoding === null || options.encoding === 'buffer'\n                        ? Buffer.concat(output.stdout)\n                        : output.stdout.join('');\n            }\n            let outputStderr = null;\n            if (output.stderr != null) {\n                outputStderr =\n                    options.encoding === null || options.encoding === 'buffer'\n                        ? Buffer.concat(output.stderr)\n                        : output.stderr.join('');\n            }\n            resolve({\n                exitCode: code,\n                stdout: outputStdout,\n                stderr: outputStderr,\n            });\n        });\n    });\n    options.handleChildProcess(spawnedProcess);\n    return promise;\n}\nfunction spawn(command, args, options) {\n    let spawnedProcess;\n    const promise = spawnInternal(command, args, {\n        ...options,\n        handleChildProcess(_spawnedProcess) {\n            spawnedProcess = _spawnedProcess;\n        },\n    });\n    promise.kill = function (signal) {\n        // TODO: kill all subprocesses on windows with wmic?\n        return spawnedProcess.kill(signal);\n    };\n    return promise;\n}\n\nvar semverCompare = function cmp (a, b) {\n    var pa = a.split('.');\n    var pb = b.split('.');\n    for (var i = 0; i < 3; i++) {\n        var na = Number(pa[i]);\n        var nb = Number(pb[i]);\n        if (na > nb) return 1;\n        if (nb > na) return -1;\n        if (!isNaN(na) && isNaN(nb)) return 1;\n        if (isNaN(na) && !isNaN(nb)) return -1;\n    }\n    return 0;\n};\n\nasync function getDependencies(packageName) {\n  const packageModule = atom.packages.getLoadedPackage(packageName);\n  const packageDependencies = packageModule && packageModule.metadata['package-deps'];\n  return Array.isArray(packageDependencies) ? packageDependencies : [];\n}\nasync function resolveDependencyPath(packageName) {\n  return atom.packages.resolvePackagePath(packageName);\n}\nasync function getInstalledDependencyVersion(dependency) {\n  var _packageModule$metada;\n\n  const packageModule = atom.packages.getLoadedPackage(dependency.name);\n  return packageModule == null ? null : (_packageModule$metada = packageModule.metadata.version) !== null && _packageModule$metada !== void 0 ? _packageModule$metada : null;\n}\n\nasync function getDependencies$1(packageName) {\n  let packageStats = null;\n\n  try {\n    packageStats = await fs__default['default'].promises.stat(packageName);\n  } catch (_) {// No Op\n  }\n\n  if (packageStats == null || !packageStats.isDirectory()) {\n    throw new Error(`[Package-Deps] Expected packageName to be a readable directory in Node.js invocation`);\n  }\n\n  let parsed = null;\n\n  try {\n    const contents = await fs__default['default'].promises.readFile(path__default['default'].join(packageName, 'package.json'), 'utf8');\n    parsed = JSON.parse(contents);\n  } catch (_) {// Ignore JSON read errors and such\n  }\n\n  const packageDependencies = parsed == null || typeof parsed !== 'object' ? [] : parsed['package-deps'];\n  return Array.isArray(packageDependencies) ? packageDependencies : [];\n}\nasync function resolveDependencyPath$1(packageName) {\n  var _process$env$ATOM_HOM;\n\n  const packageDirectory = path__default['default'].join((_process$env$ATOM_HOM = process.env.ATOM_HOME) !== null && _process$env$ATOM_HOM !== void 0 ? _process$env$ATOM_HOM : path__default['default'].join(os__default['default'].homedir(), '.atom'), 'packages', packageName);\n\n  try {\n    await fs__default['default'].promises.access(packageDirectory, fs__default['default'].constants.R_OK);\n    return packageDirectory;\n  } catch (_) {\n    return null;\n  }\n}\nasync function getInstalledDependencyVersion$1(dependency) {\n  var _manifest$version, _manifest;\n\n  const {\n    directory\n  } = dependency;\n\n  if (directory == null) {\n    // Not possible to get version without resolved directory in Node.js version\n    return null;\n  }\n\n  let manifest = null;\n\n  try {\n    manifest = JSON.parse(await fs__default['default'].promises.readFile(path__default['default'].join(directory, 'package.json'), 'utf8'));\n  } catch (_) {\n    return null;\n  }\n\n  return (_manifest$version = (_manifest = manifest) === null || _manifest === void 0 ? void 0 : _manifest.version) !== null && _manifest$version !== void 0 ? _manifest$version : null;\n}\n\n/**\n * Internal helpers\n */\n\nasync function getInstalledDependencyVersion$2(dependency) {\n  if (IS_ATOM) {\n    const atomPackageVersion = await getInstalledDependencyVersion(dependency);\n\n    if (atomPackageVersion) {\n      return atomPackageVersion;\n    } // If the package isn't activated, it won't be loaded, so fallback to reading manifest file instead\n\n  }\n\n  return getInstalledDependencyVersion$1(dependency);\n}\n/**\n * Exported helpers\n */\n\n\nconst resolveDependencyPath$2 = IS_ATOM ? resolveDependencyPath : resolveDependencyPath$1;\nfunction invariant(condition, message) {\n  if (!condition) {\n    throw new Error(message !== null && message !== void 0 ? message : 'Invariant violation');\n  }\n}\nasync function getDependencies$2(name) {\n  const dependencies = await (IS_ATOM ? getDependencies(name) : getDependencies$1(name));\n\n  if (IS_DEV) {\n    invariant(Array.isArray(dependencies), `Dependencies for ${name} are not a valid array`);\n    dependencies.forEach((item, index) => {\n      if (Array.isArray(item)) {\n        item.forEach((subitem, subindex) => {\n          const invalidMessage = `Dependency#${index}#${subindex} for ${name} is invalid`;\n          invariant(typeof subitem.name === 'string' && subitem.name.length > 0, invalidMessage);\n          invariant(subitem.minimumVersion == null || typeof subitem.minimumVersion === 'string' && subitem.minimumVersion.length > 0, invalidMessage);\n        });\n        invariant(item.length > 0, `Dependency#${index} for ${name} has no group items`);\n      } else {\n        const invalidMessage = `Dependency#${index} for ${name} is invalid`;\n        invariant(typeof item.name === 'string' && item.name.length > 0, invalidMessage);\n        invariant(item.minimumVersion == null || typeof item.minimumVersion === 'string' && item.minimumVersion.length > 0, invalidMessage);\n      }\n    });\n  }\n\n  return dependencies;\n}\nasync function shouldInstallDependency(dependency) {\n  if (dependency.directory == null) {\n    // Not installed, so install\n    return true;\n  }\n\n  if (dependency.minimumVersion == null) {\n    // Already installed and no version defined, so skip\n    return false;\n  }\n\n  const version = await getInstalledDependencyVersion$2(dependency);\n\n  if (version == null) {\n    // Unable to get current version, so install\n    return true;\n  }\n\n  return semverCompare(dependency.minimumVersion, version) === 1;\n}\nfunction isPackageIgnored(name) {\n  var _atom$config$get;\n\n  if (!IS_ATOM) {\n    // Never ignored in CLI\n    return false;\n  }\n\n  const ignoredPackages = (_atom$config$get = atom.config.get(IGNORED_CONFIG_NAME)) !== null && _atom$config$get !== void 0 ? _atom$config$get : [];\n\n  if (ignoredPackages.includes(name)) {\n    return true;\n  } // If Atom \"notifications\" package is disabled, treat the whole thing as ignored\n\n\n  if (atom.packages.isPackageDisabled('notifications')) {\n    console.warn(`Enable notifications to install dependencies for ${name}`);\n    return true;\n  }\n\n  return false;\n}\nfunction markPackageAsIgnored(name) {\n  var _atom$config$get2;\n\n  if (!IS_ATOM) {\n    // No op in CLI\n    return;\n  }\n\n  const ignoredPackages = new Set((_atom$config$get2 = atom.config.get(IGNORED_CONFIG_NAME)) !== null && _atom$config$get2 !== void 0 ? _atom$config$get2 : []);\n  ignoredPackages.add(name);\n  atom.config.set(IGNORED_CONFIG_NAME, Array.from(ignoredPackages));\n}\nconst INSTALL_VALID_TICKS = new Set(['✓', 'done']);\nconst INSTALL_VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/; // Example success output: Uninstalling linter-ui-default ✓\n\nasync function installPackage(dependency) {\n  const apmPath = IS_ATOM ? atom.packages.getApmPath() : 'apm';\n  const {\n    stdout,\n    stderr\n  } = await spawn(apmPath, ['install', dependency.name, '--production', '--color', 'false']);\n  const match = INSTALL_VALIDATION_REGEXP.exec(stdout.trim());\n\n  if (match != null && INSTALL_VALID_TICKS.has(match[2])) {\n    // Installation complete and verified\n    return;\n  }\n\n  const error = new Error(`Error installing dependency: ${dependency.name}`);\n  error.stack = stderr.trim();\n  throw error;\n}\n\nlet showResetInstruction = true;\nfunction confirmPackagesToInstall({\n  packageName,\n  dependencies\n}) {\n  return new Promise(resolve => {\n    const ungroupedDependencies = dependencies.filter(item => !Array.isArray(item));\n    const groupedDependencies = dependencies.filter(item => Array.isArray(item));\n    const skipGroups = groupedDependencies.length === 0;\n    const detail = skipGroups ? ungroupedDependencies.map(item => item.name).join(', ') : 'Something went wrong. Check your developer console';\n    const groupChoices = groupedDependencies.map(item => item[0]);\n    const notification = atom.notifications.addInfo(`${packageName} needs to install dependencies`, {\n      dismissable: true,\n      icon: 'cloud-download',\n      detail,\n      description: `Install dependenc${dependencies.length === 1 ? 'y' : 'ies'}?`,\n      buttons: [{\n        text: 'Yes',\n        onDidClick: () => {\n          if (skipGroups) {\n            resolve();\n          } else {\n            resolve(ungroupedDependencies.concat(groupChoices));\n          }\n\n          notification.dismiss();\n        }\n      }, {\n        text: 'No Thanks',\n        onDidClick: () => {\n          notification.dismiss();\n        }\n      }, {\n        text: 'Never',\n        onDidClick: () => {\n          markPackageAsIgnored(packageName);\n\n          if (showResetInstruction) {\n            showResetInstruction = false;\n            atom.notifications.addInfo('How to reset package-deps memory', {\n              dismissable: true,\n              description: \"To modify the list of ignored files invoke 'Application: Open Your Config' and change the 'atom-package-deps' section\"\n            });\n          }\n\n          notification.dismiss();\n        }\n      }]\n    });\n    notification.onDidDismiss(() => resolve([]));\n\n    if (skipGroups) {\n      return;\n    } // Handle groups\n\n\n    try {\n      var _notificationView$ele;\n\n      const notificationView = atom.views.getView(notification);\n      const notificationElement = (_notificationView$ele = notificationView === null || notificationView === void 0 ? void 0 : notificationView.element) !== null && _notificationView$ele !== void 0 ? _notificationView$ele : null;\n\n      if (notificationElement == null) {\n        throw new Error('Unable to get notification element from view');\n      }\n\n      const notificationContent = notificationElement.querySelector('.detail-content');\n\n      if (notificationContent == null) {\n        throw new Error('Content detail container not found inside the notification');\n      } // Clear the contents and add some skel\n\n\n      notificationContent.innerHTML = ''; // Add list of ungroup dependencies to the top of the notification\n\n      if (ungroupedDependencies.length > 0) {\n        const ungroupedLine = document.createElement('div');\n        ungroupedLine.innerHTML = `Packages without choices: <br /><ul><li>${ungroupedDependencies.map(item => escapeHtml_1(item.name)).join('</li><li>')}</li></ul>`;\n        notificationContent.appendChild(ungroupedLine);\n      } // Create a label line for groups\n\n\n      const groupLabelLine = document.createElement('div');\n      groupLabelLine.innerHTML = `Packages with choices:`;\n      notificationContent.appendChild(groupLabelLine); // Create one line per group with a select inside\n\n      const groupedList = document.createElement('ul');\n      groupedDependencies.forEach((item, index) => {\n        const listItem = document.createElement('li');\n        const select = document.createElement('select');\n        select.innerHTML = item.map(subitem => `<option>${escapeHtml_1(subitem.name)}</option>`).join('\\n');\n        select.addEventListener('change', () => {\n          // Change the selected value for this index for resolve to use\n          const subitem = item.find(entry => entry.name === select.value);\n\n          if (subitem != null) {\n            groupChoices[index] = subitem;\n          }\n        });\n        listItem.style.marginTop = '5px';\n        listItem.appendChild(select);\n        groupedList.appendChild(listItem);\n      });\n      notificationContent.appendChild(groupedList);\n    } catch (err) {\n      console.error('[Package-Deps] Error during showing package choices to user', err);\n    }\n  });\n}\nfunction getView({\n  packageName,\n  dependencies\n}) {\n  const failed = [];\n  const notification = atom.notifications.addInfo(`Installing ${packageName} dependencies`, {\n    detail: `Installing ${dependencies.map(item => item.name).join(', ')}`,\n    dismissable: true\n  });\n  const progress = document.createElement('progress');\n  progress.max = dependencies.length;\n  progress.style.width = '100%';\n\n  try {\n    var _notificationView$ele2;\n\n    const notificationView = atom.views.getView(notification);\n    const notificationElement = (_notificationView$ele2 = notificationView === null || notificationView === void 0 ? void 0 : notificationView.element) !== null && _notificationView$ele2 !== void 0 ? _notificationView$ele2 : null;\n\n    if (notificationElement == null) {\n      throw new Error('Unable to get notification element from view');\n    }\n\n    const notificationContent = notificationElement.querySelector('.detail-content');\n\n    if (notificationContent == null) {\n      throw new Error('Content detail container not found inside the notification');\n    }\n\n    notificationContent.appendChild(progress);\n  } catch (err) {\n    console.error('[Package-Deps] Error during showing installation progress to user', err);\n  }\n\n  return {\n    handleFailure({\n      dependency,\n      error\n    }) {\n      var _error$stack;\n\n      failed.push(dependency.name);\n      progress.value += 1;\n      console.error(`[Package-Deps] Unable to install ${dependency.name}, Error:`, (_error$stack = error === null || error === void 0 ? void 0 : error.stack) !== null && _error$stack !== void 0 ? _error$stack : error);\n    },\n\n    handleDependencyInstalled(dependency) {\n      progress.value += 1;\n    },\n\n    handleComplete() {\n      notification.dismiss();\n\n      if (failed.length > 0) {\n        atom.notifications.addWarning(`Failed to install ${packageName} dependencies`, {\n          detail: `These packages were not installed, check your console\\nfor more info.\\n${failed.join('\\n')}`,\n          dismissable: true\n        });\n      } else {\n        atom.notifications.addSuccess(`Installed ${packageName} dependencies`, {\n          detail: `Installed ${dependencies.map(item => item.name).join(', ')}`\n        });\n      }\n\n      Promise.all(dependencies.map(item => {\n        if (!failed.includes(item.name)) {\n          return atom.packages.activatePackage(item.name);\n        }\n\n        return null;\n      })).catch(err => {\n        console.error(`[Package-Deps] Error activating installed packages for ${packageName}`, err);\n      });\n    }\n\n  };\n}\n\nasync function confirmPackagesToInstall$1({\n  dependencies\n}) {\n  // No user interaction on the CLI. Install the first (aka \"default\" choice) package\n  return dependencies.map(item => Array.isArray(item) ? item[0] : item);\n}\nfunction getView$1({\n  dependencies\n}) {\n  let failed = false;\n  console.log(`Installing dependencies:\\n${dependencies.map(item => `  - ${item.name}`).join('\\n')}`);\n  return {\n    handleFailure({\n      dependency,\n      error\n    }) {\n      var _error$stack;\n\n      failed = true;\n      console.error(`Unable to install ${dependency.name}, Error:`, (_error$stack = error === null || error === void 0 ? void 0 : error.stack) !== null && _error$stack !== void 0 ? _error$stack : error);\n    },\n\n    handleDependencyInstalled(dependency) {\n      console.log('Successfully installed', dependency.name);\n    },\n\n    handleComplete() {\n      console.log('Installation complete');\n\n      if (failed) {\n        // Fail the invocation\n        process.exitCode = 1;\n      }\n    }\n\n  };\n}\n\nconst getView$2 = IS_ATOM ? getView : getView$1;\nconst confirmPackagesToInstall$2 = IS_ATOM ? confirmPackagesToInstall : confirmPackagesToInstall$1;\n\nasync function install(packageName) {\n  invariant(typeof packageName === 'string' && packageName.length > 0, '[Package-Deps] Package name is required');\n\n  if (isPackageIgnored(packageName)) {\n    // User ignored this package\n    return;\n  } // Get list of relevant dependencies\n\n\n  const dependencies = await getDependencies$2(packageName);\n\n  if (dependencies.length === 0) {\n    // Short-circuit\n    return;\n  } // Resolve directories of relevant dependencies\n\n\n  const resolvedDependencies = await Promise.all(dependencies.map(async item => {\n    if (Array.isArray(item)) {\n      return Promise.all(item.map(async subitem => ({ ...subitem,\n        directory: await resolveDependencyPath$2(subitem.name)\n      })));\n    }\n\n    return { ...item,\n      directory: await resolveDependencyPath$2(item.name)\n    };\n  })); // Filter out already installed, in range dependencies\n  // If one dependency from a group is already installed, whole group is ignored\n\n  const dependenciesToInstall = await pFilter_1(resolvedDependencies, async function (item) {\n    if (Array.isArray(item)) {\n      return (await Promise.all(item.map(subitem => shouldInstallDependency(subitem)))).every(Boolean);\n    }\n\n    return shouldInstallDependency(item);\n  });\n\n  if (dependenciesToInstall.length === 0) {\n    // Short-circuit if all have been skipped\n    return;\n  }\n\n  const chosenDependencies = await confirmPackagesToInstall$2({\n    packageName,\n    dependencies: dependenciesToInstall\n  });\n\n  if (chosenDependencies.length === 0) {\n    // Short-circuit if user interaction cancelled all\n    return;\n  }\n\n  const view = getView$2({\n    packageName,\n    dependencies: chosenDependencies\n  });\n  await pMap(chosenDependencies, async function (dependency) {\n    try {\n      await installPackage(dependency);\n      view.handleDependencyInstalled(dependency);\n    } catch (err) {\n      view.handleFailure({\n        dependency,\n        error: err\n      });\n    }\n  }, {\n    concurrency: 2\n  });\n  view.handleComplete();\n}\n\nexports.install = install;\n"],"names":["Object","defineProperty","exports","value","child_process","_child_process","fs","_fs","path","_path","_interopDefaultLegacy","e","default","os__default","_os","fs__default","path__default","extractPathRegex","pathRegex","homeDir","homedir","AggregateError","Error","constructor","errors","Array","isArray","TypeError","message","map","error","assign","stack","replace","cleanInternalStack","options","pretty","split","filter","line","pathMatches","match","includes","test","trim","m","p1","join","String","string","count","indent","includeEmptyLines","regex","repeat","indentString","super","this","name","[object Object]","Symbol","iterator","_errors","aggregateError","pMap$1","iterable","mapper","Promise","resolve","reject","concurrency","Infinity","ret","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","i","done","then","element","pMap_1","_default","pFilter","async","filterer","index","all","Boolean","pFilter_1","_default$1","IS_ATOM","atom","IS_DEV","inDevMode","inSpecMode","matchHtmlRegExp","escapeHtml_1","escape","str","exec","html","lastIndex","length","charCodeAt","substring","spawn","command","args","spawnedProcess","promise","output","stdout","stderr","on","chunk","push","handleStdout","handleStderr","code","outputStdout","encoding","Buffer","concat","outputStderr","exitCode","handleChildProcess","spawnInternal","_spawnedProcess","kill","signal","getInstalledDependencyVersion$2","dependency","atomPackageVersion","_packageModule$metada","packageModule","packages","getLoadedPackage","metadata","version","getInstalledDependencyVersion","_manifest$version","_manifest","directory","manifest","JSON","parse","promises","readFile","_","getInstalledDependencyVersion$1","resolveDependencyPath$2","packageName","resolvePackagePath","_process$env$ATOM_HOM","packageDirectory","process","env","ATOM_HOME","access","constants","R_OK","invariant","condition","getDependencies$2","dependencies","packageDependencies","getDependencies","packageStats","stat","isDirectory","parsed","contents","getDependencies$1","forEach","item","subitem","subindex","invalidMessage","minimumVersion","shouldInstallDependency","a","b","pa","pb","na","Number","nb","isNaN","semverCompare","INSTALL_VALID_TICKS","Set","INSTALL_VALIDATION_REGEXP","showResetInstruction","getView$2","failed","notification","notifications","addInfo","detail","dismissable","progress","document","createElement","max","style","width","_notificationView$ele2","notificationView","views","getView","notificationElement","notificationContent","querySelector","appendChild","err","console","handleFailure","_error$stack","handleDependencyInstalled","handleComplete","dismiss","addWarning","addSuccess","activatePackage","catch","log","confirmPackagesToInstall$2","ungroupedDependencies","groupedDependencies","skipGroups","groupChoices","icon","description","buttons","text","onDidClick","_atom$config$get2","ignoredPackages","config","get","add","set","from","markPackageAsIgnored","onDidDismiss","_notificationView$ele","innerHTML","ungroupedLine","groupLabelLine","groupedList","listItem","select","addEventListener","find","entry","marginTop","_atom$config$get","isPackageDisabled","warn","resolvedDependencies","dependenciesToInstall","every","chosenDependencies","view","stopOnError","isSafeInteger","result","pMap","apmPath","getApmPath","has","installPackage","install","$b84b25051d41e6efca358f41f$export$install"],"version":3,"file":"atom-package-deps.abef52e0.js.map"}