{
  "name": "serializable",
  "version": "1.0.0",
  "description": "A mixin for making serializable objects",
  "main": "./lib/serializable",
  "scripts": {
    "prepublish": "grunt clean lint coffee",
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/atom/serializable.git"
  },
  "bugs": {
    "url": "https://github.com/atom/serializable/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/atom/serializable/raw/master/LICENSE.md"
    }
  ],
  "dependencies": {
    "mixto": "1.x",
    "underscore-plus": "1.x",
    "get-parameter-names": "~0.1.2"
  },
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "jasmine-focused": "~0.19.0",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-cli": "~0.1.8",
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "grunt-coffeelint": "0.0.6",
    "rimraf": "~2.2.2",
    "coffee-cache": "~0.2.0"
  },
  "readme": "# Serializable\n\nThis npm provides a `Serializable` mixin to streamline the process of writing\nserializable classes. Include the mixin and implement two instance methods\n(`::serializeParams` and `::deserializeParams`) to add serialization to your\nclass.\n\n## Using Serializable Classes\n\n### Basics\n\nBefore digging into how to implement serializable classes, let's touch on how\nto use them. To serialize an object, call `::serialize`. To deserialize an\nobject, call `.deserialize` on its class with the results of a previous call to\n`::serialize`.\n\n```coffee\ntrain1 = new Train(cars: 20, hasCaboose: true)\ntrain1State = train1.serialize()\ntrain2 = Train.deserialize(train1State)\nexpect(train2.cars).toBe 20\nexpect(train2.hasCaboose).toBe true\n```\n\n### Extra Deserialize Params\n\nYou can pass `.deserialize` an optional second argument containing additional\nnon-serializable parameters which will be merged with the deserialized\nparameters when constructing the object. For example, say that trains need a\nreference to a `RailNetwork` instance, but that the `RailNetwork` isn't\nserialized as part of `Train`:\n\n```coffee\ntrain1 = new Train(cars: 20, hasCaboose: true, railNetwork: network)\ntrain1State = train1.serialize() # does not contain a serialized RailNetwork\ntrain2 = Train.deserialize(train1State, railNetwork: network)\n```\n\n## Implementing Serializable Classes\n\n### Including the Mixin\n\nThe `Serializable` mixin is implemented with the [mixto](https://github.com/atom/mixto)\nnpm. To include it, use the `.includeInto` class method or simply subclass\n`Serializable`.\n\n```coffee\nSerializable = require 'serializable'\n\nclass Automobile extends Vehicle\n  Serializable.includeInto(this)\n```\n\n### ::serializeParams()\n\nThis method should return a plain JavaScript object containing the serialized\nversion of all parameters required to reconstruct the object.\n\n```coffee\nclass Automobile extends Vehicle\n  Serializable.includeInto(this)\n  \n  constructor: (@doors=4, @engine='v8') ->\n  \n  serializeParams: -> {@doors, @engine}\n```\n\nIf all your parameters are scalars, this is all that's required. When\ndeserializing, Serializable will match up the names of the keys in the params hash\nwith the names of your constructor parameters to reconstruct your object.\n\n```coffee\nauto1 = new Automobile(2, 'v6')\nauto2 = Automobile.deserialize(auto1.serialize())\nexpect(auto2.doors).toBe 2\nexpect(auto2.engine).toBe 'v6'\n```\n\nYou can also take a params hash as your constructor argument, in which case\nSerializable won't attempt to match up constructor parameter names.\n\n```coffee\nclass Train extends Vehicle\n  Serializable.includeInto(this)\n\n  constructor: ({@cars, @hasCaboose}={}) ->\n\n  serializeParams: -> {@cars, @hasCaboose}\n```\n\n### ::deserializeParams(params)\n\nIf your params hash contains nested serialized objects, you'll need to\ndeserialize the nested objects before they are passed to the constructor of the\nparent object. You perform this deserialization in the optional\n`::deserializeParams` instance method.\n\n```coffee\nclass Plane extends Vehicle\n  constructor: (@engines, @pilot) ->\n    @pilot ?= new Pilot(name: \"Bob\", plane: this)\n  \n  serializeParams: -> {@engines, pilot: @pilot.serialize()}\n  \n  deserializeParams: (params) ->\n    params.pilot = Pilot.deserialize(params.pilot, plane: this)\n    params\n```\n\nUsing some JS trickery, this method is called *before* your object's\nconstructor, allowing you to reference the instance being deserialized when\ndeserializing its children. You can also perform pre-initialization in this\nmethod. Note that it is safe to modify the params object that is passed\ninto your method. This is convenient when only a subset of your params need to\nbe deserialized.\n\n## Polymorphic Deserialization\n\nIf you can't know the specific class of the object you are deserializing ahead\nof time, you can call `::registerDeserializers` on a superclass (or any\nserializable class) to enable polymorphic deserialization.\n\n```coffee\nVehicle.registerDeserializers(Plane, Train)\nVehicle.registerDeserializer(Automobile)\n\nvehicleStates = [plane, train, auto].map (vehicle) -> vehicle.serialize()\nvehicles = vehicleStates.map (vehicleState) -> Vehicle.deserialize(vehicleState)\n```\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/atom/serializable",
  "_id": "serializable@1.0.0",
  "_from": "serializable@^1.0.0"
}
