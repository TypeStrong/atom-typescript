{
  "name": "span-skip-list",
  "version": "0.2.0",
  "description": "A data structure for calculating running totals in multiple dimensions in O(ln(n)).",
  "main": "lib/span-skip-list.js",
  "scripts": {
    "benchmark": "./benchmark/benchmark.coffee",
    "prepublish": "grunt clean lint coffee",
    "test": "grunt test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/atom/span-skip-list.git"
  },
  "keywords": [
    "skip-list",
    "data-structure",
    "index"
  ],
  "author": {
    "name": "Nathan Sobo"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/atom/span-skip-list/raw/master/LICENSE.md"
    }
  ],
  "bugs": {
    "url": "https://github.com/atom/span-skip-list/issues"
  },
  "homepage": "http://atom.github.io/span-skip-list",
  "devDependencies": {
    "coffee-script": "~1.6.3",
    "jasmine-focused": "~0.12.0",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-cli": "~0.1.8",
    "grunt": "~0.4.1",
    "grunt-shell": "~0.2.2",
    "grunt-coffeelint": "0.0.6",
    "rimraf": "~2.2.2",
    "underscore": "~1.5.1"
  },
  "readme": "# Span Skip-List [![Build Status](https://travis-ci.org/atom/span-skip-list.png)](https://travis-ci.org/atom/span-skip-list)\n\nThis data structure stores arbitrary mappings between various dimensions and\nallows running totals to be calculated in `O(ln(n))`, where n is the number of\ntable entries. Say you have a table entries like the following:\n\n| x | y |\n|---|---|\n| 3 | 3 |\n| 5 | 2 |\n| 2 | 7 |\n| 4 | 4 |\n\nWith this data structure, you can determine how many y's you have traversed when\nyou've traversed up to a certain number of x's. For example, when you've\ntraversed up to 8 in the x dimension your total in the y dimension is 5. Here's\nan example of how you'd use the span skip list to answer that query:\n\n```coffeescript\nSpanSkipList = require 'span-skip-list'\n\n# Construct with the dimensions you want to track\nlist = new SpanSkipList('x', 'y')\n\n# Populate with entries. Splice takes the dimension in which to interpret the\n# index as a first argument. More on that later.\nentries = [\n  {x: 3, y: 3}\n  {x: 5, y: 2}\n  {x: 2, y: 7}\n  {x: 4, y: 4}\n]\nlist.splice('x', 0, 0, entries...)\nlist.getElements() # => [{x: 3, y: 3} {x: 5, y: 2} {x: 2, y: 7} {x: 4, y: 4}]\n\n# Call ::totalTo with a total in one dimension to get a total in all dimensions\n# up to the element that exceeds the target value in that dimension.\nlist.totalTo(8, 'x') # => { x: 8, y: 5 }\nlist.totalTo(10, 'x') # => { x: 10, y: 12 }\n\n# Note that you always get the total exclusive of the exceeding element. In this\n# case, x = 11 returns the same total as x = 10 because including the next\n# element ({x: 4, y: 4} would make x = 14, which exceeds x = 11.\nlist.totalTo(11, 'x') # => { x: 10, y: 12 }\n\n# The splice occurs at the index of the first element that exceeds the given\n# index in the given dimension. In this case, the splice at x = 3 replaces the\n# element {x: 5, y: 2} with the given element. The ::splice method returns an\n# array of removed elements, list like Array::splice.\nlist.splice('x', 3, 1, {x: 7, y: 1}) # => [{x: 5, y: 2}]\nlist.getElements() # => [{x: 3, y: 3}, {x: 7, y: 1}, {x: 2, y: 7}, {x: 4, y: 4}]\n\n# You can splice in any tracked dimension:\nlist.splice('y', 4, 0, {x: 2, y: 2})\nlist.getElements() # => [{x: 3, y: 3}, {x: 7, y: 1}, {x: 2, y: 2}, {x: 2, y: 7}, {x: 4, y: 4}]\n\n# You can also splice and run totals in the special 'elements' dimension, which\n# counts each element as a unit. This returns the total of the first 3 elements:\nlist.totalTo(3, 'elements') # => {x: 12, y: 6}\n\n# And this splices at the given element index:\nlist.splice('elements', 2, 1) # => [{x: 2, y: 2}]\nlist.getElements() # => [{x: 3, y: 3}, {x: 7, y: 1}, {x: 2, y: 7}, {x: 4, y: 4}]\n```\n",
  "readmeFilename": "README.md",
  "_id": "span-skip-list@0.2.0",
  "_from": "span-skip-list@~0.2.0"
}
